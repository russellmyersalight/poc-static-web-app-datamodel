<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AI Ticket Prediction Playground</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin-top: 2em;
      background-color: #f8f9fa;
    }
    .thinking-icon {
      font-size: 2rem;
      animation: pulse 1s infinite ease-in-out;
      margin-top: 10px;
      text-align: center;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    img.pulsate { width: 100px; animation: pulse 2s infinite; }
  </style>
</head>
<body>
<div class="container">

  <div class="text-center mb-5">
    <h1 class="display-5">AI Ticket Classification Playground</h1>
    <small><small class="text-muted" id="app-version">Version ...</small></small>
    &nbsp;&nbsp;<small><small><small><small><small id="envText">t</small></small></small></small></small>
  </div>

  <!-- Tabs -->
  <ul class="nav nav-tabs mb-4" id="predictionTabs" role="tablist">
    <li class="nav-item" role="presentation">
      <button class="nav-link active" id="single-tab" data-bs-toggle="tab" data-bs-target="#single" type="button" role="tab">Single Ticket</button>
    </li>
    <li class="nav-item" role="presentation">
      <button class="nav-link" id="bulk-tab" data-bs-toggle="tab" data-bs-target="#bulk" type="button" role="tab">Bulk CSV</button>
    </li>
  </ul>

  <div class="tab-content" id="predictionTabsContent">

    <!-- Single Ticket Tab -->
    <div class="tab-pane fade show active" id="single" role="tabpanel">
      <div class="card shadow-sm p-4 mb-4">
        <h4>Single Ticket Classification</h4>
        <form id="ticketForm">
          <div class="mb-3">
            <label for="shortDesc" class="form-label">Short Description</label>
            <input type="text" class="form-control" id="shortDesc" placeholder="Enter short description" required>
          </div>
           <div class="mb-3">
            <label for="longDesc" class="form-label">Long Description</label>
            <textarea class="form-control" id="longDesc" rows="5" placeholder="Enter long description" required
                      onkeydown="handleEnterSubmit(event)"></textarea>
          </div>
          <div class="text-center">
            <img id="myImage" class="pulsate d-none" src="img/Designer.png" alt="Pulsating Image">
          </div>
          <div class="text-center mt-3">
            <button type="button" class="btn btn-primary btn-lg" onclick="submitTicket()">Submit</button>
          </div>
        </form>

        <div class="card shadow-sm p-4 mt-4 d-none" id="result">
          <h2 class="mb-4">Predictions</h2>
            <div class="table-responsive">
            <table class="table table-bordered table-striped">
              <tbody>
                <tr><th>Service Tower</th><td class="text-primary" id="tower"></td></tr>
                <tr><th>Intent</th><td class="text-primary" id="intent"></td></tr>
                <tr><th>Intent Description</th><td class="text-primary" id="intent-description"></td></tr>
                <tr><th>Summary</th><td id="summary"></td></tr>
                <tr><th>Proposed Solution</th><td id="solution"></td></tr>
              </tbody>
            </table>
              <div class="text-center mt-3">
                <button id="showDiagnosticsBtn" class="btn btn-info d-none" onclick="toggleDiagnostics()">Show Diagnostics</button>
              </div>

              <div class="card mt-3 d-none" id="diagnosticsCard">
                <h4 class="mb-3">API Diagnostics</h4>
                <div class="table-responsive">
                  <table class="table table-bordered table-striped" id="diagnosticsTable">
                   <thead>
                      <tr>
                        <th>Step</th>
                        <th>Time Taken (s)</th>
                        <th>Prompt Tokens</th>
                        <th>Completion Tokens</th>
                      </tr>
                   </thead>
                    <tbody>
                      <!-- Dynamically populated -->
                    </tbody>
                  </table>
                </div>
              </div>
          </div>

        </div>
      </div>
    </div>

    <!-- Bulk CSV Tab -->
    <div class="tab-pane fade" id="bulk" role="tabpanel">
      <div class="card shadow-sm p-4 mb-4">
        <h4>Bulk Ticket Classification (via CSV)</h4>
        <p class="text-muted">Upload a CSV file with header including at least these columns: <strong>"ticket_id", "short_description"</strong> and <strong>"long_description"</strong></p>
        <div class="mb-3">
          <input type="file" class="form-control" id="csvFileInput" accept=".csv">
        </div>
        <div class="text-center">
          <button class="btn btn-success" onclick="processCSV()">Upload & Predict</button>
        </div>
        <div class="mt-3" id="bulkStatus"></div>
        <div class="text-center mt-3">
          <button id="downloadCsvBtn" class="btn btn-secondary d-none" onclick="downloadCSV()">Download Results</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
let latestTimeTaken = null;

// let API_ENDPOINT = 'https://func-t-weu-assistant-genai-02.azurewebsites.net/api/predict'; //TSTNF
// let API_ENDPOINT = "http://localhost:7075/api/predict"; // C# local
let API_ENDPOINT = "http://localhost:7071/api/predict" // Python local

let API_ENDPOINT_EXTRA = "==wVJdxVuFzAhfB2NheeVI903ZX9JVWhnACD7U1LUnL4NZHB0Tqce7pE=edoc?".split('').reverse().join('');  //TSTNF

 const queryString = window.location.search;
 const urlParams = new URLSearchParams(queryString);

 let CONCURRENCY_LIMIT = 3;
 const concurrencyLimitParam = urlParams.get('concurrency');

 if (concurrencyLimitParam == null) {

 }
 else {
   CONCURRENCY_LIMIT = parseInt(concurrencyLimitParam);
 }

 let TARGET_ENV = 't';

const targetEnvParam = urlParams.get('target');

 if (targetEnvParam == null) {

 }
 else {
   TARGET_ENV = targetEnvParam;
 }

 targetEnvChanged();




async function submitTicket() {
  const loader = document.getElementById('myImage');
  const resultBox = document.getElementById('result');
  loader.classList.remove('d-none');
  resultBox.classList.add('d-none');

  const shortDesc = document.getElementById('shortDesc').value;
  const longDesc = document.getElementById('longDesc').value;

  try {
    const response = await fetch(API_ENDPOINT + API_ENDPOINT_EXTRA, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ shortDescription: shortDesc, description: longDesc })
    });
    const data = await response.json();

    // Store timeTaken globally for diagnostics
    latestTimeTaken = data.timeTaken;
    window.lastTokensUsed = data.tokensUsed;

    document.getElementById('tower').textContent = data.result.predictedServiceTower;
    document.getElementById('intent').textContent = data.result.predictedIntent;
    document.getElementById('intent-description').textContent = data.result.predictedIntentDescription;
    document.getElementById('solution').textContent = data.result.proposedSolution;
    document.getElementById('summary').textContent = data.result.summary;

    loader.classList.add('d-none');
    resultBox.classList.remove('d-none');

    // Show toggle button and hide diagnostics table initially
    const diagBtn = document.getElementById('showDiagnosticsBtn');
    diagBtn.classList.remove('d-none');
    diagBtn.textContent = 'Show Diagnostics';
    document.getElementById('diagnosticsCard').classList.add('d-none');

  } catch (error) {
    console.error('Error fetching prediction:', error);
    loader.classList.add('d-none');
    alert("An error occurred. Please try again.");
  }
}

/* ===== CSV UPLOAD & PARALLEL BULK PREDICTION WITH PROGRESS BAR ===== */
let bulkResults = [];

envChar = "t";

/* ===== ROBUST CSV PARSER THAT HANDLES QUOTES, COMMAS & LINE BREAKS ===== */
function parseCSV(text) {
  const rows = [];
  let current = [];
  let i = 0;
  let value = '';
  let inQuotes = false;

  while (i < text.length) {
    const char = text[i];

    if (inQuotes) {
      if (char === '"') {
        if (text[i + 1] === '"') { // escaped quote
          value += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        value += char;
      }
    } else {
      if (char === '"') {
        inQuotes = true;
      } else if (char === ',') {
        current.push(value);
        value = '';
      } else if (char === '\r') {
        if (text[i + 1] === '\n') i++; // skip \n after \r
        current.push(value);
        rows.push(current);
        current = [];
        value = '';
      } else if (char === '\n') {
        current.push(value);
        rows.push(current);
        current = [];
        value = '';
      } else {
        value += char;
      }
    }
    i++;
  }

  // Add last value
  current.push(value);
  rows.push(current);

  return rows;
}

async function processCSV() {
  const fileInput = document.getElementById('csvFileInput');
  const statusDiv = document.getElementById('bulkStatus');
  const downloadBtn = document.getElementById('downloadCsvBtn');
  bulkResults = [];
  downloadBtn.classList.add('d-none');
  statusDiv.innerHTML = '';

  if (!fileInput.files.length) {
    alert('Please select a CSV file first.');
    return;
  }

  const file = fileInput.files[0];
  const text = await file.text();
  const rows = parseCSV(text);

  if (rows.length < 2) {
    alert("CSV is empty or invalid.");
    return;
  }

  const headers = rows[0].map(h => h.trim());
  const lowerHeaders = headers.map(h => h.toLowerCase());
  const idIndex = lowerHeaders.indexOf('ticket_id');
  const shortIndex = lowerHeaders.indexOf('short_description');
  const longIndex = lowerHeaders.indexOf('long_description');

  if (idIndex === -1 || shortIndex === -1 || longIndex === -1) {
    alert("CSV must include headers: ticket_id, short_description, long_description");
    return;
  }

  // Parse tickets keeping all original fields
  const tickets = rows.slice(1).map(cols => {
    const ticket = {};
    headers.forEach((h, idx) => {
      ticket[h] = cols[idx]?.trim() || '';
    });
    return ticket;
  }).filter(t => t['short_description'] && t['long_description']);

  const total = tickets.length;
  let completed = 0;
  const startTime = Date.now();

  // Progress UI
  statusDiv.innerHTML = `
    <div class="mb-2 text-info">Processing ${total} tickets <span id="initialisationMsg">... Initialising</span><span>&nbsp;&nbsp;&nbsp;<small><small><small>(concurrency: ${CONCURRENCY_LIMIT})</small></small></small></span></div>
    <div class="progress" style="height: 25px;">
      <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated"
           role="progressbar" style="width: 0%">0%</div>
    </div>
    <div class="mt-2 small text-muted" id="progressText"></div>
  `;

  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const progressInitText = document.getElementById("initialisationMsg");

  const updateProgress = () => {
    progressInitText.hidden = true;
    const percent = Math.round((completed / total) * 100);
    const elapsed = (Date.now() - startTime) / 1000;
    const avgPerTicket = elapsed / (completed || 1);
    const remaining = total - completed;
    const eta = avgPerTicket * remaining;
    const etaFormatted = eta < 5 ? `${eta.toFixed(1)}s` :
                         eta < 60 ? `${Math.round(eta)}s` :
                         `${Math.round(eta / 60)}m ${Math.round(eta % 60)}s`;
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
    progressText.innerHTML = `Processed ${completed}/${total} (${percent}%) — ETA: ${etaFormatted}`;
  };

  async function processBatch(startIndex) {
    const ticket = tickets[startIndex];
    if (!ticket) return;

    try {
      const payload = {
        shortDescription: ticket['short_description'],
        description: ticket['long_description']
      };

      const response = await fetch(API_ENDPOINT + API_ENDPOINT_EXTRA, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await response.json();

      bulkResults[startIndex] = {
        ...ticket, // preserve all original fields
        GENAI_service_tower: data.result.predictedServiceTower || '',
        GENAI_intent: data.result.predictedIntent || '',
        GENAI_intent_description: data.result.predictedIntentDescription || '',
        GENAI_proposed_solution: data.result.proposedSolution || '',
        GENAI_summary: data.result.summary || ''
      };
    } catch (err) {
      console.error(`Error on ticket ${ticket['ticket_id']}:`, err);
      bulkResults[startIndex] = {
        ...ticket,
        service_tower: 'Error',
        intent: 'Error',
        intent_description: '',
        proposed_solution: '',
        summary: ''
      };
    } finally {
      completed++;
      updateProgress();
    }

    const nextIndex = startIndex + CONCURRENCY_LIMIT;
    if (nextIndex < tickets.length) {
      await processBatch(nextIndex);
    }
  }

  const workers = [];
  for (let i = 0; i < CONCURRENCY_LIMIT && i < tickets.length; i++) {
    workers.push(processBatch(i));
  }

  await Promise.all(workers);

  progressBar.classList.remove('progress-bar-animated');
  progressBar.classList.add('bg-success');
  progressBar.textContent = '100%';
  progressText.innerHTML = `✅ Completed processing all ${bulkResults.length} tickets.`;
  downloadBtn.classList.remove('d-none');
}

function downloadCSV() {
  if (bulkResults.length === 0) return;

  // Preserve original headers + new prediction columns
  const originalHeaders = Object.keys(bulkResults[0]).filter(h =>
    !['GENAI_service_tower','GENAI_intent','GENAI_intent_description','GENAI_proposed_solution','GENAI_summary'].includes(h)
  );
  const newHeaders = ['GENAI_service_tower','GENAI_intent','GENAI_intent_description','GENAI_proposed_solution','GENAI_summary'];
  const headers = [...originalHeaders, ...newHeaders];

  const csvContent =
    headers.join(',') + '\n' +
    bulkResults.map(row =>
      headers.map(h => `"${(row[h] || '').replace(/"/g, '""')}"`).join(',')
    ).join('\n');

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ticket_predictions.csv';
  a.click();
  URL.revokeObjectURL(url);
}

function handleEnterSubmit(event) {
  if (event.key === "Enter" && !event.shiftKey) {
    event.preventDefault(); // prevent newline
    submitTicket();         // call your existing submit function
  }
}

function showDiagnostics() {
  if (!latestTimeTaken) return;

  const tbody = document.getElementById('diagnosticsTable').querySelector('tbody');
  tbody.innerHTML = ''; // clear previous rows

  for (const [step, time] of Object.entries(latestTimeTaken)) {
    const tr = document.createElement('tr');
    const tdStep = document.createElement('td');
    tdStep.textContent = step;
    const tdTime = document.createElement('td');
    tdTime.textContent = time;
    tr.appendChild(tdStep);
    tr.appendChild(tdTime);
    tbody.appendChild(tr);
  }

  document.getElementById('diagnosticsCard').classList.remove('d-none');
}

function toggleDiagnostics() {
  const diagCard = document.getElementById('diagnosticsCard');
  const diagBtn = document.getElementById('showDiagnosticsBtn');

  if (diagCard.classList.contains('d-none')) {
    if (latestTimeTaken) {
      const tbody = diagCard.querySelector('tbody');
      tbody.innerHTML = '';

      const tokenData = window.lastTokensUsed || {};

      // Mapping between step names and tokens object keys
      const tokenMap = {
        serviceTowerPredict: tokenData.service_tower || {},
        intentPredict: tokenData.intent || {},
        createTicketSummary: tokenData.ticket_summary || {},
        createProposedSolution: tokenData.proposed_solution || {}
      };

      let totalPrompt = 0;
      let totalCompletion = 0;

      for (const [step, time] of Object.entries(latestTimeTaken)) {
        const tr = document.createElement('tr');
        const tdStep = document.createElement('td');
        tdStep.textContent = step;

        const tdTime = document.createElement('td');
        tdTime.textContent = time;

        let prompt = '-';
        let completion = '-';

        if (step !== 'overall') {
          const tData = tokenMap[step] || {};
          prompt = tData.prompt ?? '-';
          completion = tData.completion ?? '-';
          if (!isNaN(parseInt(tData.prompt))) totalPrompt += parseInt(tData.prompt);
          if (!isNaN(parseInt(tData.completion))) totalCompletion += parseInt(tData.completion);
        }

        const tdPrompt = document.createElement('td');
        const tdCompletion = document.createElement('td');

        // For the "overall" row, display the total tokens
        if (step === 'overall') {
          tdPrompt.textContent = totalPrompt || '-';
          tdCompletion.textContent = totalCompletion || '-';
          tr.classList.add('table-secondary', 'fw-bold');
        } else {
          tdPrompt.textContent = prompt;
          tdCompletion.textContent = completion;
        }

        tr.appendChild(tdStep);
        tr.appendChild(tdTime);
        tr.appendChild(tdPrompt);
        tr.appendChild(tdCompletion);
        tbody.appendChild(tr);
      }

      // Add endpoint row at the bottom
      const endpointRow = document.createElement('tr');
      endpointRow.innerHTML = `
        <td>Endpoint</td>
        <td colspan="3">${API_ENDPOINT}</td>
      `;
      tbody.appendChild(endpointRow);
    }

    diagCard.classList.remove('d-none');
    diagBtn.textContent = 'Hide Diagnostics';
  } else {
    diagCard.classList.add('d-none');
    diagBtn.textContent = 'Show Diagnostics';
  }
}

function displayEnv() {

  document.getElementById("envText").innerHTML = TARGET_ENV;


}

function targetEnvChanged() {
  switch (TARGET_ENV) {
    case "t":
      API_ENDPOINT = 'https://func-t-weu-assistant-genai-02.azurewebsites.net/api/predict'; //TSTNF
      API_ENDPOINT_EXTRA = "==wVJdxVuFzAhfB2NheeVI903ZX9JVWhnACD7U1LUnL4NZHB0Tqce7pE=edoc?".split('').reverse().join('');  //TSTNF
      break;
    case "q":
      API_ENDPOINT = 'https://func-q-weu-assistant-genai-01.azurewebsites.net/api/predict';  //QAS
      API_ENDPOINT_EXTRA = "==QBiZRCuFzA5JO_TzGtA1cXbwYYvs9Tjcvw4fTj2gElJCTysc4V7NLm=edoc?".split('').reverse().join(''); // QAS
      break;
    case "l":
      API_ENDPOINT = "http://localhost:7071/api/predict" // Python local
      break;
  }

  displayEnv();



}




   fetch('config.json')
    .then(response => {
      if (!response.ok) {
        throw new Error('Failed to load config.json');
      }
      return response.json();
    })
    .then(config => {
      const versionEl = document.getElementById('app-version');
      if (versionEl) {
        versionEl.textContent = `Version ${config.version}`;
      }
    })
    .catch(error => {
      console.error('Error loading config:', error);
    });

</script>
</body>
</html>
