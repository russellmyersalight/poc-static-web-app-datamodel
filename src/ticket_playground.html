<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AI Ticket Prediction Playground</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin-top: 2em;
      background-color: #f8f9fa;
    }
    .thinking-icon {
      font-size: 2rem;
      animation: pulse 1s infinite ease-in-out;
      margin-top: 10px;
      text-align: center;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    img.pulsate { width: 100px; animation: pulse 2s infinite; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<div class="container">

  <div class="text-center mb-5">
    <h1 class="display-5">AI Ticket Classification Playground</h1>
    <small><small class="text-muted" id="app-version">Version ...</small></small>
    &nbsp;&nbsp;<small><small><small id="envText">t</small></small></small>
      <small><small><small id="langText">python</small></small></small>
      <small><small><small id="endpointText"></small></small></small>

  </div>

  <!-- Tabs -->
  <ul class="nav nav-tabs mb-4" id="predictionTabs" role="tablist">
    <li class="nav-item" role="presentation">
      <button class="nav-link active" id="single-tab" data-bs-toggle="tab" data-bs-target="#single" type="button" role="tab">Single Ticket</button>
    </li>
    <li class="nav-item" role="presentation">
      <button class="nav-link" id="bulk-tab" data-bs-toggle="tab" data-bs-target="#bulk" type="button" role="tab">Bulk CSV</button>
    </li>
  </ul>

  <div class="tab-content" id="predictionTabsContent">

    <!-- Single Ticket Tab -->
    <div class="tab-pane fade show active" id="single" role="tabpanel">
      <div class="card shadow-sm p-4 mb-4">
        <h4>Single Ticket Classification</h4>
        <form id="ticketForm">
          <div class="mb-3">
            <label for="shortDesc" class="form-label">Short Description</label>
            <input type="text" class="form-control" id="shortDesc" placeholder="Enter short description" required>
          </div>
           <div class="mb-3">
            <label for="longDesc" class="form-label">Long Description</label>
            <textarea class="form-control" id="longDesc" rows="5" placeholder="Enter long description" required
                      onkeydown="handleEnterSubmit(event)"></textarea>
          </div>
          <div class="text-center">
            <img id="myImage" class="pulsate d-none" src="img/Designer.png" alt="Pulsating Image">
          </div>
          <div class="text-center mt-3">
            <button type="button" class="btn btn-primary btn-lg" onclick="submitTicket()">Submit</button>
          </div>
        </form>

        <div class="card shadow-sm p-4 mt-4 d-none" id="result">
          <h2 class="mb-4">Predictions</h2>
            <div class="table-responsive">
            <table class="table table-bordered table-striped">
              <tbody>
                <tr><th>Service Tower</th><td class="text-primary" id="tower"></td></tr>
                <tr><th>Intent</th><td class="text-primary" id="intent"></td></tr>
                <tr><th>Intent Description</th><td class="text-primary" id="intent-description"></td></tr>
                <tr><th>Summary</th><td id="summary"></td></tr>
                <tr><th>Proposed Solution</th><td id="solution"></td></tr>
              </tbody>
            </table>
              <div id="citation-info">
                   Citation links: ...
              </div>
               <div id="feedback-section" class="text-center mt-3 d-none">
                <span>Was this prediction helpful?</span><br>
                <button id="feedback-up" class="btn btn-outline-secondary btn-sm mx-1" onclick="submitFeedback(true)">üëç</button>
                <button id="feedback-down" class="btn btn-outline-secondary btn-sm mx-1" onclick="submitFeedback(false)">üëé</button>
                <div id="feedback-msg" class="mt-2 text-muted"></div>
              </div>
              <div class="text-center mt-3">
                <button id="showDiagnosticsBtn" class="btn btn-info d-none" onclick="toggleDiagnostics()">Show Diagnostics</button>
              </div>

              <div class="card mt-3 d-none" id="diagnosticsCard">
                <h4 class="mb-3">API Diagnostics</h4>
                <div class="table-responsive">
                  <table class="table table-bordered table-striped" id="diagnosticsTable">
                   <thead>
                      <tr>
                        <th>Step</th>
                        <th>Time Taken (s)</th>
                        <th>Prompt Tokens</th>
                        <th>Completion Tokens</th>
                      </tr>
                   </thead>
                    <tbody>
                      <!-- Dynamically populated -->
                    </tbody>
                  </table>
                </div>
              </div>
          </div>

        </div>
      </div>
    </div>

    <!-- Bulk Excel Tab -->
      <div class="tab-pane fade" id="bulk" role="tabpanel">
        <div class="card shadow-sm p-4 mb-4">
          <h4>Bulk Ticket Classification (via Excel)</h4>
          <p class="text-muted">
            Upload an Excel file (.xlsx) with a header including at least these columns:
            <strong>"TICKETID"</strong>, <strong>"SHORT_DESCRIPTION"</strong>, and <strong>"DESCRIPTION"</strong>
          </p>
          <div class="mb-3">
            <input type="file" class="form-control" id="excelFileInput" accept=".xlsx,.xls">
          </div>
          <div class="text-center">
            <button class="btn btn-success" onclick="processExcel()">Upload & Predict</button>
          </div>
          <div class="mt-3" id="bulkStatus"></div>
          <div class="text-center mt-3">
            <button id="downloadExcelBtn" class="btn btn-secondary d-none" onclick="downloadExcel()">Download Results</button>
          </div>
        </div>
      </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
let latestTimeTaken = null;

// let API_ENDPOINT = 'https://func-t-weu-assistant-genai-02.azurewebsites.net/api/predict'; //TSTNF
// let API_ENDPOINT = "http://localhost:7075/api/predict"; // C# local
let API_ENDPOINT = "http://localhost:7071/api/predict" // Python local

let API_ENDPOINT_EXTRA = "==wVJdxVuFzAhfB2NheeVI903ZX9JVWhnACD7U1LUnL4NZHB0Tqce7pE=edoc?".split('').reverse().join('');  //TSTNF

 const queryString = window.location.search;
 const urlParams = new URLSearchParams(queryString);

 let CONCURRENCY_LIMIT = 1;
 const concurrencyLimitParam = urlParams.get('concurrency');

 if (concurrencyLimitParam == null) {

 }
 else {
   CONCURRENCY_LIMIT = parseInt(concurrencyLimitParam);
 }

 let TARGET_INDEX = "ticket-qanda-simple";
 const targetIndexParam = urlParams.get('index');

 if (targetIndexParam == null) {

 }
 else {
   TARGET_INDEX = targetIndexParam;
 }


 let TARGET_ENV = 'q';
 let TARGET_LANG = "python";

 const targetEnvParam = urlParams.get('env');

 if (targetEnvParam == null) {

 }
 else {
   TARGET_ENV = targetEnvParam;
 }

 targetEnvChanged();


 const targetLangParam = urlParams.get('target');

 if (targetLangParam == null) {

 }
 else {
   TARGET_LANG = targetLangParam;
 }

 targetLangChanged();



async function submitTicket() {
  const loader = document.getElementById('myImage');
  const resultBox = document.getElementById('result');
  loader.classList.remove('d-none');
  resultBox.classList.add('d-none');

  const shortDesc = document.getElementById('shortDesc').value;
  const longDesc = document.getElementById('longDesc').value;

  try {
    const response = await fetch(API_ENDPOINT + API_ENDPOINT_EXTRA, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ shortDescription: shortDesc, description: longDesc, targetIndex: TARGET_INDEX })
    });
    const data = await response.json();

    // Store timeTaken globally for diagnostics
    latestTimeTaken = data.timeTaken;
    window.lastTokensUsed = data.tokensUsed;

    document.getElementById('tower').textContent = data.result.predictedServiceTower;
    document.getElementById('intent').textContent = data.result.predictedIntent;
    document.getElementById('intent-description').textContent = data.result.predictedIntentDescription;
    document.getElementById('solution').textContent = data.result.proposedSolution.length == 0 ? "No knowledge articles found" : data.result.proposedSolution;
    document.getElementById('summary').textContent = data.result.summary;

    let formattedCitationLinks = formatCitationLinks(data.result.proposedSolution, data.citationLinks);
    citationList = dictToHtmlList(formattedCitationLinks);
    if (Object.keys(formattedCitationLinks).length == 0) {
       document.getElementById("citation-info").innerHTML = "Citation reference links: None";
    }
    else {
      document.getElementById("citation-info").innerHTML = "Citation reference links:<br>" + citationList;
    }

    showFeedbackButtons();

    loader.classList.add('d-none');
    resultBox.classList.remove('d-none');


    // Show toggle button and hide diagnostics table initially
    const diagBtn = document.getElementById('showDiagnosticsBtn');
    diagBtn.classList.remove('d-none');
    diagBtn.textContent = 'Show Diagnostics';
    document.getElementById('diagnosticsCard').classList.add('d-none');

  } catch (error) {
    console.error('Error fetching prediction:', error);
    loader.classList.add('d-none');
    alert("An error occurred. Please try again.");
  }
}

function formatCitationLinks(proposedSolution, citationLinks) {

      if (citationLinks == null) {
        return {};
      }

      let usedRefIds = [...proposedSolution.matchAll(/\[ref_id:(\d+)\]/g)]
                .map(m => Number(m[1]));  // extract and convert the capturing group
      usedRefIds =  usedRefIds.sort((a, b) => a - b);

      var fullReferences = {};

      citationLinks.forEach((link, index) => {
          if (usedRefIds.includes(parseInt(link.refId))) {

            if (link.url in fullReferences) {
               fullReferences[link.url].push(link.refId);
            }
            else {
              fullReferences[link.url] = [link.refId];
            }
            var xx = 1;

          }

      });

      const entries = Object.entries(fullReferences);
      // Map over the entries to swap key and value
      const swappedEntries = entries.map(([key, value]) => [value, key]);
      // Convert the swapped entries back into an object
      const fullReferencesSwapped = Object.fromEntries(swappedEntries);


      return fullReferencesSwapped;
}

function dictToHtmlList(dict) {
  let html = "<ul>\n";

  for (const [key, value] of Object.entries(dict)) {
    html += `  <li><strong>${key}</strong>: <small>${value}</small></li>\n`;
  }

  html += "</ul>";
  return html;
}

function showFeedbackButtons() {
  const feedbackSection = document.getElementById('feedback-section');
  const feedbackMsg = document.getElementById('feedback-msg');
  feedbackMsg.textContent = '';

  // Reset buttons
  const upBtn = document.getElementById('feedback-up');
  const downBtn = document.getElementById('feedback-down');
  upBtn.disabled = false;
  downBtn.disabled = false;
  upBtn.style.border = "";
  upBtn.style.boxShadow = "";
  downBtn.style.border = "";
  downBtn.style.boxShadow = "";

  feedbackSection.classList.remove('d-none');
}

async function submitFeedback(isPositive) {
  const feedbackMsg = document.getElementById('feedback-msg');
  const upBtn = document.getElementById('feedback-up');
  const downBtn = document.getElementById('feedback-down');

  // Disable buttons immediately
  upBtn.disabled = true;
  downBtn.disabled = true;

  // Subtle visual cue: add border & shadow to selected button
  const selectedBtn = isPositive ? upBtn : downBtn;
  selectedBtn.style.border = "2px solid #000";
  selectedBtn.style.boxShadow = "0 0 5px rgba(0,0,0,0.3)";

  const payload = {
    ticket: {
      shortDescription: document.getElementById('shortDesc').value,
      longDescription: document.getElementById('longDesc').value,
      serviceTower: document.getElementById('tower').textContent,
      intent: document.getElementById('intent').textContent,
      intentDescription: document.getElementById('intent-description').textContent,
      summary: document.getElementById("summary").textContent,
      proposedSolution: document.getElementById('solution').textContent,
    },
    feedback: isPositive ? "positive" : "negative"
  };
  console.log("Feedback entered: ");
  console.log(payload);

  try {
    // Optional: send feedback to your API
    // await fetch('/api/feedback', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify(payload)
    // });

    feedbackMsg.textContent = "Thank you for your feedback!";
  } catch (err) {
    console.error("Error sending feedback:", err);
    feedbackMsg.textContent = "Error submitting feedback. Please try again.";
    // Re-enable buttons if sending failed
    upBtn.disabled = false;
    downBtn.disabled = false;
    selectedBtn.style.border = "";
    selectedBtn.style.boxShadow = "";
  }
}





/* ===== CSV UPLOAD & PARALLEL BULK PREDICTION WITH PROGRESS BAR ===== */
let bulkResults = [];

envChar = "t";

/* ===== ROBUST CSV PARSER THAT HANDLES QUOTES, COMMAS & LINE BREAKS ===== */
async function processExcel() {
  const fileInput = document.getElementById('excelFileInput');
  const statusDiv = document.getElementById('bulkStatus');
  const downloadBtn = document.getElementById('downloadExcelBtn');
  bulkResults = [];
  downloadBtn.classList.add('d-none');
  statusDiv.innerHTML = '';

  if (!fileInput.files.length) {
    alert('Please select an Excel file first.');
    return;
  }

  const file = fileInput.files[0];
  const data = await file.arrayBuffer();
  const workbook = XLSX.read(data, { type: 'array' });
  const sheet = workbook.Sheets[workbook.SheetNames[0]];
  const jsonData = XLSX.utils.sheet_to_json(sheet, { defval: '' });

  if (jsonData.length === 0) {
    alert("Excel sheet is empty or invalid.");
    return;
  }

  const headers = Object.keys(jsonData[0]);
  const lowerHeaders = headers.map(h => h.toLowerCase());
  const idIndex = lowerHeaders.indexOf('ticketid');
  const shortIndex = lowerHeaders.indexOf('short_description');
  const longIndex = lowerHeaders.indexOf('description');

  if (idIndex === -1 || shortIndex === -1 || longIndex === -1) {
    alert("Excel must include at least these headers: TICKETID, SHORT_DESCRIPTION, DESCRIPTION");
    return;
  }

  const tickets = jsonData.filter(t => t['SHORT_DESCRIPTION'] && t['DESCRIPTION']);
  const total = tickets.length;
  let completed = 0;
  const startTime = Date.now();

  statusDiv.innerHTML = `
    <div class="mb-2 text-info">Processing ${total} tickets
      <span id="initialisationMsg">... Initialising</span>
      <span>&nbsp;&nbsp;&nbsp;<small><small>(concurrency: ${CONCURRENCY_LIMIT})</small></small></span>
    </div>
    <div class="progress" style="height: 25px;">
      <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated"
           role="progressbar" style="width: 0%">0%</div>
    </div>
    <div class="mt-2 small text-muted" id="progressText"></div>
  `;

  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const progressInitText = document.getElementById("initialisationMsg");

  const updateProgress = () => {
    progressInitText.hidden = true;
    const percent = Math.round((completed / total) * 100);
    const elapsed = (Date.now() - startTime) / 1000;
    const avgPerTicket = elapsed / (completed || 1);
    const remaining = total - completed;
    const eta = avgPerTicket * remaining;
    const etaFormatted = eta < 5 ? `${eta.toFixed(1)}s` :
                         eta < 60 ? `${Math.round(eta)}s` :
                         `${Math.round(eta / 60)}m ${Math.round(eta % 60)}s`;
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
    progressText.innerHTML = `Processed ${completed}/${total} (${percent}%) ‚Äî ETA: ${etaFormatted}`;
  };

  async function processBatch(startIndex) {
    const ticket = tickets[startIndex];
    if (!ticket) return;

    try {
      const payload = {
        shortDescription: ticket['SHORT_DESCRIPTION'],
        description: ticket['DESCRIPTION'],
        targetIndex: TARGET_INDEX
      };

      const response = await fetch(API_ENDPOINT + API_ENDPOINT_EXTRA, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await response.json();

      bulkResults[startIndex] = {
        ...ticket,
        GENAI_service_tower: data.result.predictedServiceTower || '',
        GENAI_intent: data.result.predictedIntent || '',
        GENAI_intent_description: data.result.predictedIntentDescription || '',
        GENAI_proposed_solution: data.result.proposedSolution || '',
        GENAI_summary: data.result.summary || ''
      };
    } catch (err) {
      console.error(`Error on ticket ${ticket['TICKETID']}:`, err);
      bulkResults[startIndex] = {
        ...ticket,
        GENAI_service_tower: 'Error',
        GENAI_intent: 'Error'
      };
    } finally {
      completed++;
      updateProgress();
    }

    const nextIndex = startIndex + CONCURRENCY_LIMIT;
    if (nextIndex < tickets.length) {
      await processBatch(nextIndex);
    }
  }

  const workers = [];
  for (let i = 0; i < CONCURRENCY_LIMIT && i < tickets.length; i++) {
    workers.push(processBatch(i));
  }

  await Promise.all(workers);

  progressBar.classList.remove('progress-bar-animated');
  progressBar.classList.add('bg-success');
  progressBar.textContent = '100%';
  progressText.innerHTML = `‚úÖ Completed processing all ${bulkResults.length} tickets.`;
  downloadBtn.classList.remove('d-none');
}

function downloadExcel() {
  if (bulkResults.length === 0) return;

  const fileInput = document.getElementById('excelFileInput');
  const inputFile = fileInput.files[0];

  // Default name if input missing
  let inputName = "ticket_predictions.xlsx";
  if (inputFile && inputFile.name) {
    const dotIndex = inputFile.name.lastIndexOf('.');
    if (dotIndex !== -1) {
      inputName =
        inputFile.name.substring(0, dotIndex) + "_PREDICTION_RESULTS.xlsx";
    } else {
      inputName = inputFile.name + "_PREDICTION_RESULTS.xlsx";
    }
  }

  const ws = XLSX.utils.json_to_sheet(bulkResults);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Predictions");

  XLSX.writeFile(wb, inputName);
}

function handleEnterSubmit(event) {
  if (event.key === "Enter" && !event.shiftKey) {
    event.preventDefault(); // prevent newline
    submitTicket();         // call your existing submit function
  }
}

function showDiagnostics() {
  if (!latestTimeTaken) return;

  const tbody = document.getElementById('diagnosticsTable').querySelector('tbody');
  tbody.innerHTML = ''; // clear previous rows

  for (const [step, time] of Object.entries(latestTimeTaken)) {
    const tr = document.createElement('tr');
    const tdStep = document.createElement('td');
    tdStep.textContent = step;
    const tdTime = document.createElement('td');
    tdTime.textContent = time;
    tr.appendChild(tdStep);
    tr.appendChild(tdTime);
    tbody.appendChild(tr);
  }

  document.getElementById('diagnosticsCard').classList.remove('d-none');
}

function toggleDiagnostics() {
  const diagCard = document.getElementById('diagnosticsCard');
  const diagBtn = document.getElementById('showDiagnosticsBtn');

  if (diagCard.classList.contains('d-none')) {
    if (latestTimeTaken) {
      const tbody = diagCard.querySelector('tbody');
      tbody.innerHTML = '';

      const tokenData = window.lastTokensUsed || {};

      // Mapping between step names and tokens object keys
      const tokenMap = {
        serviceTowerPredict: tokenData.service_tower ||  tokenData.serviceTowerPredict || {},
        intentPredict: tokenData.intent || tokenData.intentPredict ||  {},
        createTicketSummary: tokenData.ticket_summary || tokenData.createTicketSummary ||  {},
        createProposedSolution: tokenData.proposed_solution ||  tokenData.proposedSolution || {}
      };

      let totalPrompt = 0;
      let totalCompletion = 0;

      for (const [step, time] of Object.entries(latestTimeTaken)) {
        const tr = document.createElement('tr');
        const tdStep = document.createElement('td');
        tdStep.textContent = step;

        const tdTime = document.createElement('td');
        tdTime.textContent = time;

        let prompt = '-';
        let completion = '-';

        let tokenStep = "";

        switch (step) {
          case 'serviceTower':
            tokenStep = "serviceTowerPredict";
            break;
          case 'intent':
            tokenStep = "intentPredict";
            break;
          case 'summariseTicket':
            tokenStep = "createTicketSummary";
            break;
          case 'proposeSolution':
            tokenStep = "createProposedSolution";
            break;
          default:
            tokenStep = step;

        }


        if (tokenStep !== 'overall') {
          const tData = tokenMap[tokenStep] || {};
          prompt = tData.prompt ?? '-';
          completion = tData.completion ?? '-';
          if (!isNaN(parseInt(tData.prompt))) totalPrompt += parseInt(tData.prompt);
          if (!isNaN(parseInt(tData.completion))) totalCompletion += parseInt(tData.completion);
        }

        const tdPrompt = document.createElement('td');
        const tdCompletion = document.createElement('td');

        // For the "overall" row, display the total tokens
        if (tokenStep === 'overall') {
          tdPrompt.textContent = totalPrompt || '-';
          tdCompletion.textContent = totalCompletion || '-';
          tr.classList.add('table-secondary', 'fw-bold');
        } else {
          tdPrompt.textContent = prompt;
          tdCompletion.textContent = completion;
        }

        tr.appendChild(tdStep);
        tr.appendChild(tdTime);
        tr.appendChild(tdPrompt);
        tr.appendChild(tdCompletion);
        tbody.appendChild(tr);
      }

      // Add endpoint row at the bottom
      const endpointRow = document.createElement('tr');
      endpointRow.innerHTML = `
        <td>Endpoint</td>
        <td colspan="3">${API_ENDPOINT}</td>
      `;
      tbody.appendChild(endpointRow);
    }

    diagCard.classList.remove('d-none');
    diagBtn.textContent = 'Hide Diagnostics';
  } else {
    diagCard.classList.add('d-none');
    diagBtn.textContent = 'Show Diagnostics';
  }
}

function displayEnv() {

  var displayEnvs = {"t": "tstnf",
                     "q": "qas",
                     "l": "local"}

  document.getElementById("envText").innerHTML = displayEnvs[TARGET_ENV];


}

function displayLang() {

  if  (TARGET_LANG === "python") {
    document.getElementById("langText").innerHTML = TARGET_LANG;
  }
  else {
    document.getElementById("langText").innerHTML = "C#";
  }


}

function displayEndpoint() {


  document.getElementById("endpointText").innerHTML = "(" + API_ENDPOINT + ")";


}

function targetLangOrEnvChanged() {
   switch (TARGET_ENV) {
    case "t":
      if (TARGET_LANG == "python") {
        API_ENDPOINT = 'https://func-t-weu-assistant-genai-02.azurewebsites.net/api/predict'; //TSTNF
        API_ENDPOINT_EXTRA = "==wVJdxVuFzAhfB2NheeVI903ZX9JVWhnACD7U1LUnL4NZHB0Tqce7pE=edoc?".split('').reverse().join('');  //TSTNF
      }
      else {
        API_ENDPOINT = 'https://func-t-weu-assistant-02.azurewebsites.net/api/predict'; //TSTNF
        API_ENDPOINT_EXTRA = "==g9Bl6tuFzAPH_YpoZW7TIjOzakEJsco07zRGmxbclrIcTGiIC48O9W=edoc?".split('').reverse().join('');  //TSTNF

      }
      break;
    case "q":
      if (TARGET_LANG == "python") {

          API_ENDPOINT = 'https://func-q-weu-assistant-genai-01.azurewebsites.net/api/predict';  //QAS
          API_ENDPOINT_EXTRA = "==QBiZRCuFzA5JO_TzGtA1cXbwYYvs9Tjcvw4fTj2gElJCTysc4V7NLm=edoc?".split('').reverse().join(''); // QAS
      }
      else {
           API_ENDPOINT = 'https://func-q-weu-assistant-01.azurewebsites.net/api/predict';  //QAS
           API_ENDPOINT_EXTRA = "==gewZ1wuFzABZKuyz_K9LFe29NXjaJR4x689iCs_Ab2N0B5_qyJX7nn=edoc?".split('').reverse().join('');  // QAS
      }
      break;
    case "l":

      if (TARGET_LANG == "python") {
          API_ENDPOINT = "http://localhost:7071/api/predict" // Python local
      }
      else {
         API_ENDPOINT = "http://localhost:7075/api/predict" // C#  local
      }
      break;
  }

}

function targetEnvChanged() {
  targetLangChanged();
  // switch (TARGET_ENV) {
  //   case "t":
  //     API_ENDPOINT = 'https://func-t-weu-assistant-genai-02.azurewebsites.net/api/predict'; //TSTNF
  //     API_ENDPOINT_EXTRA = "==wVJdxVuFzAhfB2NheeVI903ZX9JVWhnACD7U1LUnL4NZHB0Tqce7pE=edoc?".split('').reverse().join('');  //TSTNF
  //     break;
  //   case "q":
  //     API_ENDPOINT = 'https://func-q-weu-assistant-genai-01.azurewebsites.net/api/predict';  //QAS
  //     API_ENDPOINT_EXTRA = "==QBiZRCuFzA5JO_TzGtA1cXbwYYvs9Tjcvw4fTj2gElJCTysc4V7NLm=edoc?".split('').reverse().join(''); // QAS
  //     break;
  //   case "l":
  //     API_ENDPOINT = "http://localhost:7071/api/predict" // Python local
  //     break;
  // }


  displayEnv();
  displayEndpoint();



}

function targetLangChanged() {
  targetLangOrEnvChanged();

  // switch (TARGET_LANG) {
  //   case "t":
  //     API_ENDPOINT = 'https://func-t-weu-assistant-genai-02.azurewebsites.net/api/predict'; //TSTNF
  //     API_ENDPOINT_EXTRA = "==wVJdxVuFzAhfB2NheeVI903ZX9JVWhnACD7U1LUnL4NZHB0Tqce7pE=edoc?".split('').reverse().join('');  //TSTNF
  //     break;
  //   case "q":
  //     API_ENDPOINT = 'https://func-q-weu-assistant-genai-01.azurewebsites.net/api/predict';  //QAS
  //     API_ENDPOINT_EXTRA = "==QBiZRCuFzA5JO_TzGtA1cXbwYYvs9Tjcvw4fTj2gElJCTysc4V7NLm=edoc?".split('').reverse().join(''); // QAS
  //     break;
  //   case "l":
  //     API_ENDPOINT = "http://localhost:7071/api/predict" // Python local
  //     break;
  // }

  displayLang();
  displayEndpoint();



}




   fetch('config.json')
    .then(response => {
      if (!response.ok) {
        throw new Error('Failed to load config.json');
      }
      return response.json();
    })
    .then(config => {
      const versionEl = document.getElementById('app-version');
      if (versionEl) {
        versionEl.textContent = `Version ${config.version}`;
      }
    })
    .catch(error => {
      console.error('Error loading config:', error);
    });

</script>
</body>
</html>
